e8b58425d0d43082868b44cfea793a9444429001e6a22dccc8a6d0dc1563c25d
2026-11-18T14:55:55.620Z
function getDeviceInfo() {
  return {
    os: navigator.platform || "unknown",
    browser: navigator.userAgent || "unknown",
    deviceWidth: window.screen.width,
    deviceHeight: window.screen.height,
    devicePixelRatio: window.devicePixelRatio,
    deviceMemory: navigator.deviceMemory || 0,
    deviceColorDepth: window.screen.colorDepth || 0,
    hardwareConcurrency: navigator.hardwareConcurrency || 0
  };
}

// spoofFingerprint - run as early as possible (Sources → Snippets)
(() => {
  // Desired values
  const spoof = {
    userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36",
    platform: "Win32",
    deviceWidth: 1920,
    deviceHeight: 1080,
    devicePixelRatio: 1,
    deviceMemory: 8,
    deviceColorDepth: 24,
    hardwareConcurrency: 12
  };

  // 1) navigator.userAgent and navigator.platform
  try {
    Object.defineProperty(navigator, 'userAgent', {
      get: () => spoof.userAgent,
      configurable: true
    });
  } catch (e) { /* may be blocked in some browser builds */ }

  try {
    Object.defineProperty(navigator, 'platform', {
      get: () => spoof.platform,
      configurable: true
    });
  } catch (e) {}

  // 2) navigator.deviceMemory and navigator.hardwareConcurrency
  try {
    Object.defineProperty(navigator, 'deviceMemory', {
      get: () => spoof.deviceMemory,
      configurable: true
    });
  } catch (e) {}

  try {
    Object.defineProperty(navigator, 'hardwareConcurrency', {
      get: () => spoof.hardwareConcurrency,
      configurable: true
    });
  } catch (e) {}

  // 3) window.devicePixelRatio
  try {
    Object.defineProperty(window, 'devicePixelRatio', {
      get: () => spoof.devicePixelRatio,
      configurable: true
    });
  } catch (e) {}

  // 4) screen.* properties (width, height, colorDepth)
  try {
    Object.defineProperty(window, 'screen', {
      value: Object.assign({}, window.screen, {
        width: spoof.deviceWidth,
        height: spoof.deviceHeight,
        availWidth: spoof.deviceWidth,
        availHeight: spoof.deviceHeight,
        colorDepth: spoof.deviceColorDepth
      }),
      configurable: true,
      writable: false
    });
    // Also patch the prototype getters (some scripts access Screen.prototype)
    try {
      const ScreenProto = Object.getPrototypeOf(window.screen);
      Object.defineProperty(ScreenProto, 'width', { get: () => spoof.deviceWidth, configurable: true });
      Object.defineProperty(ScreenProto, 'height', { get: () => spoof.deviceHeight, configurable: true });
      Object.defineProperty(ScreenProto, 'colorDepth', { get: () => spoof.deviceColorDepth, configurable: true });
    } catch (e) {}
  } catch (e) {
    // Fallback: try defining on window.screen directly
    try {
      Object.defineProperty(window.screen, 'width', { get: () => spoof.deviceWidth, configurable: true });
      Object.defineProperty(window.screen, 'height', { get: () => spoof.deviceHeight, configurable: true });
      Object.defineProperty(window.screen, 'colorDepth', { get: () => spoof.deviceColorDepth, configurable: true });
    } catch (err) {}
  }

  // 5) innerWidth / innerHeight (some sites use these instead of screen)
  try {
    Object.defineProperty(window, 'innerWidth', { get: () => spoof.deviceWidth, configurable: true });
    Object.defineProperty(window, 'innerHeight', { get: () => spoof.deviceHeight, configurable: true });
  } catch (e) {}

  // 6) helper log
  console.info("Fingerprint spoof applied:", spoof);
})();
---------------------------------
// Canvas-perturbation (educational) - run as early as possible
(() => {
  const SEED = 12345; // change this to get a different perturbation
  function pseudoRandom(seed) {
    // small xorshift PRNG
    let x = seed || 123456789;
    return function() {
      x ^= x << 13;
      x ^= x >>> 17;
      x ^= x << 5;
      return (Math.abs(x) % 256) / 255;
    };
  }

  const prng = pseudoRandom(SEED);

  // Patch HTMLCanvasElement.prototype.toDataURL
  const origToDataURL = HTMLCanvasElement.prototype.toDataURL;
  HTMLCanvasElement.prototype.toDataURL = function(...args) {
    try {
      const ctx = this.getContext && this.getContext('2d');
      if (ctx) {
        // draw a 1×1 almost-transparent pixel in a corner derived from PRNG
        ctx.save();
        const x = Math.floor(prng() * Math.max(1, this.width - 1));
        const y = Math.floor(prng() * Math.max(1, this.height - 1));
        // Use an alpha that is subtle but not always fully transparent
        ctx.fillStyle = `rgba(${Math.floor(prng()*255)},${Math.floor(prng()*255)},${Math.floor(prng()*255)},0.02)`;
        ctx.fillRect(x, y, 1, 1);
        ctx.restore();
      }
    } catch (e) {
      // ignore if site uses strict CSP or other protections
    }
    return origToDataURL.apply(this, args);
  };

  // Patch toBlob similarly
  const origToBlob = HTMLCanvasElement.prototype.toBlob;
  if (origToBlob) {
    HTMLCanvasElement.prototype.toBlob = function(cb, type, quality) {
      try {
        const ctx = this.getContext && this.getContext('2d');
        if (ctx) {
          ctx.save();
          const x = Math.floor(prng() * Math.max(1, this.width - 1));
          const y = Math.floor(prng() * Math.max(1, this.height - 1));
          ctx.fillStyle = `rgba(${Math.floor(prng()*255)},${Math.floor(prng()*255)},${Math.floor(prng()*255)},0.02)`;
          ctx.fillRect(x, y, 1, 1);
          ctx.restore();
        }
      } catch (e) {}
      return origToBlob.call(this, cb, type, quality);
    };
  }

  console.info('Canvas perturbation applied (seed=', SEED, ')');
})();
----------------------
function detectCanvasTampering() {
    const canvas = document.createElement("canvas");
    const funcStr = HTMLCanvasElement.prototype.toDataURL.toString();
    const pointerOk = (canvas.toDataURL === HTMLCanvasElement.prototype.toDataURL);
         if (!funcStr.includes('[native code]') || !pointerOk) {
        return "tampered";
        } else {
        return "not tampered";
        }
  }
----------------------
// attacker: wrapper + fake toString
(function(){
  const orig = HTMLCanvasElement.prototype.toDataURL;
  function wrapper(...args) {
    // Could perturb pixels here, return static data, or call orig
    // Example: call original, but could alter result
    return orig.apply(this, args);
  }
  // Make toString return a native-like representation
  wrapper.toString = function() { return "function toDataURL() { [native code] }"; };

  // Replace on prototype (so existing and new canvases see same reference)
  HTMLCanvasElement.prototype.toDataURL = wrapper;
})();

console.log(detectCanvasTampering()); // -> "not tampered"  (FALSE NEGATIVE)
